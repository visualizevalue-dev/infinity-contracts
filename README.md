# Infinity (NFT)

## setup

1. run `yarn` to install project packages
2. run any hardhat task via `npx hardhat` or `hh` (if you have the [shorthand](https://hardhat.org/hardhat-runner/docs/guides/command-line-completion) installed)
3. e.g. run tests via `npx hardhat test`

## intro

> *"ages like 0.008 eth..."*

infinities are an infinitely collectable collectible in the ethereum ecosystem.

you create infinities by depositing 0.008 eth into the contract. burning an infinity token returns that eth to the owner of the nft.

the visuals are randomly arranged grids with symbols created of the base shape that makes up the checks and opepen projects, generated and rendered fully onchain.

## core functionality

there are basically three different logic flows in the contract:

1. **generate**: create a token based on an eth deposit
2. **degenerate**: burn a token and withdraw the deposited eth
3. **regenerate**: burn + remint a token to generate new artwork

each of those functions has a corresponding _xyzMany_ call, which performs the action on multiple tokens at once.

## design considerations

the contract is a simplified version of a typical OpenZeppelin ERC1155 token. 

the most important adjustment is that infinities cannot be `approved` to operators, like typical NFTs. thus, programmability of infinity tokens is restricted to token `onReceive` hooks.

a few unused functionalities like beforeTransfer and afterTransfer hooks and approval checks were removed from the base contract, to make token interactions as cheap as possible.

token attributes and visuals are seeded via token ids, which are generated by using a combination of `prevrandao`, the account address and the remaining gas during mint.

by using randomness during mint, users cannot specify a specific token id to mint, unless that token already exists. existing tokens can be reminted indefinitely by anyone at any time. over time, this will visualize *"taste"* at the collection level.
in order to save gas during token generation, we don't store whether a token has been minted. in order to validate a token exists, minters have to additionally pass the account address of any existing holder of the token as the token `source`.

unlike all other accounts, the visualize value creator account (currently `visualizevalue.eth`) has the right to force-mint any token it pleases.

as a nod to the black check (see checks.art), every 4096th token is a monochromatic, black on white design. token #0 is referred to the "genesis" piece, a full flower single infinity check, and will be airdropped to eligible checks elements (see elements.checks.art) auction bidders.

### reasoning for preventing traditional approval flows

infinities are to be collected, not traded on marketplaces. there is zero cost benefit to do so, so we consciously prevent doing this via the typical flows used for it (approvals). the only time people would trade these is if they don't know they are infinitely mintable on the contract.

programmability still exists, by utilizing the onReceive hooks outlined in the [EIP](https://eips.ethereum.org/EIPS/eip-1155) (contracts can run arbitrary logic when being sent infinity tokens).


## deployment (bytecode state of `7e4e389...f722ba`) (out of date)

- salt: `0x5d41dbb04825b039a98d9169dbfc569f510c6e25f4995cb6822e4015f13fd716`; final address: `0x000D39614481839520901aF2eC5bB81F87888888`
- salt: `0x3997c69a39dd451b5503e35287918552c9384b529b80b77476919bfe2def4f36`; final address: `0x0000943A32B3902d5e6C9aF906009c0024148888`

## TODO's

### Add more test cases:

- [x] ether receive hook
	- [x] mint x tokens of the same tokenId when sending the amount for x
	- [x] mint no token when sending too little
	- [x] refund remaining after minting/not minting tokens
	- [x] fails if remaining cannot be sent
- [x] generate
	- [x] only emit message when message is given
	- [x] fails if recipient is zero address
	- [x] ~~test of receive hook~~ (in ERC1155 tests)
- [x] generateExisting
	- [x] fails if source address does not have any token with tokenId
	- [x] works for non existing tokenIds if VV
- [x] regenerate
	- [x] fails if sender does not have amount of tokenId
	- [x] fails if tokenId does not exist (should be the same reason as above)
	- [x] mint the same amount of tokens burned of a random id
- [x] degenerate
	- [x] fails if sender does not have amount of tokenId
	- [x] fails if tokenId does not exist (should be the same reason as above)
	- [x] refunds correct amount if sender did have amount of tokenId
	- [x] ~~fails if refund cannot be sent~~ (redundant)
- [ ] generateMany
	- [x] fails if recipients and amounts have different length
	- [x] fails if not sending the exact amount for nr tokens minted
	- [x] mint amount of different random tokenIds to given recipients
	- [x] fails if any recipient is zero address
	- [x] fails if any amount is zero
- [ ] generateManyExisting
	- [ ] fails if arguments have different lengths
	- [ ] fails if not sending the exact amount for nr tokens minted
	- [ ] fails if any source address does not have any token with tokenId
	- [ ] works for non existing tokenIds if VV
	- [ ] fails if any recipient is zero address
	- [ ] fails if any amount is zero (I think this currently does not fail and would emit a zero amount Transfer event)
	- [ ] mint amount of existing tokenIds to given recipients
- [ ] regenerateMany
	- [ ] fails if arguments have different lengths (currently does not)
	- [ ] fails if sender does not have amount of any tokenId
	- [ ] mint and burn the same amount of tokens
- [ ] degenerateMany
	- [ ] fails if arguments have different lengths
	- [ ] fails if refund cannot be sent
	- [ ] refunds correct value if all tokens could be burnt
